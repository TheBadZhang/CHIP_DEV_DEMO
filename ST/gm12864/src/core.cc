#include "core.h"
#include "common.h"
#include <cstring>
uint32_t fac_us;

void HAL_Delay_us_init(uint8_t SYSCLK) {
	fac_us=SYSCLK;
}

void HAL_Delay_us(uint32_t nus) {
	uint32_t ticks;
	uint32_t told,tnow,tcnt=0;
	uint32_t reload=SysTick->LOAD;
	ticks=nus*fac_us;
	told=SysTick->VAL;
	while(1)
	{
		tnow=SysTick->VAL;
		if(tnow!=told)
		{
			if(tnow<told)tcnt+=told-tnow;
			else tcnt+=reload-tnow+told;
			told=tnow;
			if(tcnt>=ticks)break;
		}
	};
}





/********************金逸晨**************************本公司模块SDA,SCK已内置上拉电阻，
*****************GM12864-59N  4PIN IIC LCD FOR STM32F103*************
*****STM32F103驱动**************************
***** PB5----3  SCK   ,  PB6----4  SDA   ,
***** BY:GU
********************************************************/


// #include "stm32f10x.h"
/**********SPI引脚分配，连接LCD屏，更具实际情况修改*********/

#define IIC_SCK_PIN 5
#define IIC_SDA_PIN 6

#define LCD_DIS_CHINA_ROT  0
#define LCD_COMMAND_NUMBER  16
#define LCD_COLUMN_NUMBER 128
#define LCD_LINE_NUMBER 64
#define LCD_COLUMN_OFFSET 0
#define LCD_PAGE_NUMBER LCD_LINE_NUMBER/8
/**********SPI引脚分配，连接LCD屏，更具实际情况修改*********/
#define IIC_SCK_0 HAL_GPIO_WritePin(CLK_GPIO_Port,CLK_Pin, GPIO_PIN_RESET)
#define IIC_SCK_1 HAL_GPIO_WritePin(CLK_GPIO_Port,CLK_Pin, GPIO_PIN_SET)
#define IIC_SDA_0 HAL_GPIO_WritePin(SDA_GPIO_Port,SDA_Pin, GPIO_PIN_RESET)
#define IIC_SDA_1 HAL_GPIO_WritePin(SDA_GPIO_Port,SDA_Pin, GPIO_PIN_SET)
#define delay_ms HAL_Delay
// #define IIC_SCK_0  GPIOB->BRR=0X0020       // 设置sck接口到PB5   清零
// #define IIC_SCK_1  GPIOB->BSRR=0X0020       //置位
// #define IIC_SDA_0  GPIOB->BRR=0X0040       // 设置SDA接口到PB6
// #define IIC_SDA_1  GPIOB->BSRR=0X0040

unsigned char ACK=0;
const unsigned char  LCD_init_cmd[LCD_COMMAND_NUMBER]= {
	0xe2, //软复位
	0x2c, //升压步聚1
	0x2e, //升压步聚2
	0x2f, //升压步聚3
	0xF8,//The Booster set
	0x00,//The Booster set 4x
	0xA2,//0xA2=1/9 Bias
	0x24, //粗调对比度，可设置范围0x20～0x27
	0x81, //微调对比度
	0x31, //微调对比度的值，可设置范围0x00～0x3f
	0xa2, //1/9 偏压比（bias）
	#if (LCD_DIS_CHINA_ROT == 180)
	0xA1, //列扫描顺序：从左到右
	0xc0, //行扫描顺序：反序
	#else
	0xA0, //列扫描顺序：从左到右
	0xc8, //行扫描顺序：反序
	#endif
	0xa6, //正显
	0x40, //起始行：第一行开始
	0xaf, //开显示
};
unsigned char  picture_tab[]={
/*------------------------------------------------------------------------------
;  列行式，低位在前，阴码
;  宽×高（像素）: 128×64
------------------------------------------------------------------------------*/
	0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x44,0x08,0x00,0x18,0x48,0x28,0xC8,0x08,0x28,0x48,0x18,0x00,
0x40,0x40,0xFC,0x40,0x40,0xFC,0x00,0x00,0xF8,0x00,0x00,0xFC,0x00,0x40,0x40,0xA0,
0x90,0x88,0x84,0x88,0x90,0x20,0x40,0x40,0x00,0x00,0x40,0x44,0xD8,0x20,0xF0,0xAC,
0xA8,0xE8,0xB8,0xA8,0xE0,0x00,0x00,0x00,0xC0,0x7C,0x54,0x54,0x54,0x54,0x54,0x54,
0x7C,0x40,0x40,0x00,0x00,0xF0,0x90,0x90,0x90,0xFC,0x90,0x90,0x90,0xF0,0x00,0x00,
0x00,0x80,0x88,0x88,0x88,0x88,0x88,0xE8,0xA8,0x98,0x8C,0x88,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,0x3E,0x01,0x10,0x11,0x09,0x05,0x3F,0x05,0x09,0x11,0x11,0x00,
0x08,0x18,0x0F,0x24,0x14,0x0F,0x00,0x00,0x0F,0x00,0x00,0x3F,0x00,0x20,0x22,0x2A,
0x32,0x22,0x3F,0x22,0x32,0x2A,0x22,0x20,0x00,0x00,0x20,0x10,0x0F,0x10,0x28,0x24,
0x23,0x20,0x2F,0x28,0x2A,0x2C,0x00,0x30,0x0F,0x04,0x3D,0x25,0x15,0x15,0x0D,0x15,
0x2D,0x24,0x24,0x00,0x00,0x07,0x04,0x04,0x04,0x1F,0x24,0x24,0x24,0x27,0x20,0x38,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x81,0x41,0x21,0x21,0x61,0x01,0x01,0x21,0xE1,0xE1,0x01,0xE1,0xE1,
0x21,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x21,0xE1,0x21,0x21,0x21,0x61,0x01,0x01,
0x21,0x21,0xE1,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0xC1,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x21,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0F,0x10,0x20,0x24,0x1C,0x04,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x22,0x22,0x27,0x30,0x00,0x00,
0x20,0x20,0x3F,0x20,0x20,0x00,0x00,0x1E,0x25,0x25,0x25,0x16,0x00,0x00,0x1E,0x21,
0x21,0x21,0x13,0x00,0x01,0x01,0x1F,0x21,0x21,0x00,0x00,0x00,0x21,0x3F,0x22,0x21,
0x01,0x00,0x00,0x1E,0x21,0x21,0x21,0x1E,0x00,0x21,0x3F,0x22,0x01,0x01,0x3E,0x20,
0x00,0x21,0x21,0x3F,0x20,0x20,0x00,0x00,0x1E,0x21,0x21,0x21,0x13,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xF0,0x08,0x04,0x04,0x04,0x0C,0x00,0xF0,0x08,0x04,0x04,0x08,0xF0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0x04,0x00,
0x00,0x00,0x00,0x00,0x0C,0x04,0xFC,0x04,0x0C,0x00,0x04,0xFC,0x04,0x04,0x08,0xF0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x81,0x82,0x84,0x84,0x84,0x82,0x80,0x81,0x82,0x84,0x84,0x82,0x81,
0x80,0x80,0x86,0x86,0x80,0x80,0x80,0x80,0x80,0x85,0x83,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x84,0x87,0x84,0x84,
0x84,0x86,0x80,0x80,0x80,0x84,0x87,0x84,0x80,0x80,0x84,0x87,0x84,0x84,0x82,0x81,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF

};

/**************************IIC模块发送函数************************************************

 *************************************************************************/
//写入  最后将SDA拉高，以等待从设备产生应答
void IIC_write(unsigned char date) {
	unsigned char i, temp;
	temp = date;

	for(i=0; i<8; i++) {
		IIC_SCK_0;
		if ((temp&0x80)==0)
			IIC_SDA_0;
		else IIC_SDA_1;
		temp = temp << 1;
		delay_us(1);
		IIC_SCK_1;
		delay_us(1);

	}
	IIC_SCK_0;
	delay_us(1);
	IIC_SDA_1;
	delay_us(1);
	IIC_SCK_1;
//								不需要应答
//	if (READ_SDA==0)
//		ACK = 1;
//	else ACK =0;
	delay_us(1);
	IIC_SCK_0;
	delay_us(1);


}
//启动信号
//SCL在高电平期间，SDA由高电平向低电平的变化定义为启动信号
void IIC_start()
{
	IIC_SDA_1;
	delay_us(1);
	IIC_SCK_1;
	delay_us(1);				   //所有操作结束释放SCL
	IIC_SDA_0;
	delay_us(3);
	IIC_SCK_0;

	IIC_write(0x7E);

}

//停止信号
//SCL在高电平期间，SDA由低电平向高电平的变化定义为停止信号
void IIC_stop() {
	IIC_SDA_0;
	delay_us(1);
	IIC_SCK_1;
	delay_us(3);
	IIC_SDA_1;

}

void LCD_send_cmd(unsigned char o_command) {

	IIC_start();
	IIC_write(0x00);
	IIC_write(o_command);
	IIC_stop();
}
void LCD_send_data(unsigned char o_data) {
	IIC_start();
	IIC_write(0x40);
	IIC_write(o_data);
	IIC_stop();
}
void Column_set(unsigned char column) {
	column+=LCD_COLUMN_OFFSET;
	LCD_send_cmd(0x10|(column>>4));    //设置列地址高位
	LCD_send_cmd(0x00|(column&0x0f));   //设置列地址低位

}
void Page_set(unsigned char page) {
	LCD_send_cmd(0xb0+page);
}
void LCD_clear(void) {
	unsigned char page,column;
	for(page=0;page<LCD_PAGE_NUMBER;page++) {            //page loop

		Page_set(page);
		Column_set(0);
		for(column=0;column<LCD_COLUMN_NUMBER;column++) {	//column loop

			LCD_send_data(0x00);
		}
	}
}
void LCD_full(void) {
	unsigned char page,column;
	for(page=0;page<LCD_PAGE_NUMBER;page++) {            //page loop

		Page_set(page);
		Column_set(0);
		for(column=0;column<LCD_COLUMN_NUMBER;column++) {	//column loop

			LCD_send_data(0xff);
		}
	}
}
void LCD_init(void) {
	unsigned char i;
	for(i=0;i<LCD_COMMAND_NUMBER;i++) {
		LCD_send_cmd(LCD_init_cmd[i]);
	}
}

void Picture_display(const unsigned char *ptr_pic) {
	unsigned char page,column;
	for(page=0;page<(LCD_LINE_NUMBER/8);page++) {       //page loop

	Page_set(page);
	Column_set(0);
	for(column=0;column<LCD_COLUMN_NUMBER;column++) {	//column loop

		LCD_send_data(*ptr_pic++);
	}
	}
}
void Picture_ReverseDisplay(const unsigned char *ptr_pic) {
	unsigned char page,column,data;
	for(page=0;page<(LCD_LINE_NUMBER/8);page++) {       //page loop

		Page_set(page);
		Column_set(0);
		for(column=0;column<LCD_COLUMN_NUMBER;column++) {	//column loop

			data=*ptr_pic++;
			data=~data;
			LCD_send_data(data);
		}
	}
}




// uint8_t uart1_rxbuf[10];                // 用于存放接收到的数据
char str[3][60];
#define A(a) ((int)a)/100
#define B(b) ((int)b)%100
char i2c_address[100];
void core(void) {

	// HAL_GPIO_TogglePin(RST_GPIO_Port, RST_Pin);
	// HAL_GPIO_TogglePin(RST_GPIO_Port, RST_Pin);
	// U8G2_SSD1327_MIDAS_128X128_f_4W_HW_SPI u8g22(U8G2_R0);
	// u8g22.setFont(u8g2_font_6x13_tf);
	// u8g22.begin();
	// HAL_Delay(1000);
	// U8G2_ST7567_JLX12864_F_2ND_HW_I2C u8g2(U8G2_R0);
	// u8g2.setFont(u8g2_font_6x13_tf);
	// u8g2.begin();
	// HAL_Delay_us_init(64);

	// MPU6050_Init();
	// __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);// 启用空闲中断
	// HAL_UART_Receive_DMA(&huart1, (uint8_t*)uart1_rxbuf, 1024);
	// HAL_UARTEx_ReceiveToIdle_IT(&huart1, (uint8_t*)uart1_rxbuf, 1024);
	// HAL_UART_Receive_IT(&huart2, (uint8_t *)&uart1_rxbuf, 1);
	// __HAL_DMA_DISABLE_IT(&hdma_usart1_rx, DMA_IT_HT);  // 关闭DMA hite
	HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,GPIO_PIN_SET);

	LCD_init();
	LCD_full();
	delay_ms(10000);
	LCD_clear();
	while (true) {
	Picture_display(picture_tab);
	delay_ms(5000);

	Picture_ReverseDisplay(picture_tab);
	delay_ms(5000);
	LCD_clear();

	// HAL_UART_Receive_IT(&huart1, (uint8_t *)&uart1_rxbuf, 1);
		// while(HAL_UART_Receive(&huart1, (uint8_t *)uart1_rxbuf, 1, 1) != HAL_OK);
		// HAL_UART_Transmit(&huart1,(uint8_t *)uart1_rxbuf,1,10);
		// u8g2_SetContrast(&u8g2, 255);
		// for (int i = 0; i < 0b10000000; i++) {
		// 	if(HAL_I2C_IsDeviceReady(&hi2c1, i<<1, 1, 10) == HAL_OK) {
		// 		HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,GPIO_PIN_RESET);
		// 		sprintf(i2c_address, "add:%x", i);
		// 		HAL_UART_Transmit(&huart2, (uint8_t*)i2c_address, strlen(i2c_address), 1000);
		// 	}
		// 	HAL_Delay(50);
		// }
		// HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDRESS , (uint8_t*)"hello world", 11, 100);
		// u8g2.clearBuffer();
		// for (int i = 0; i < 128; i++) {
		// 	for (int j = 0; j < 64; j++) {
		// 		if ((i^j)%2)
		// 			u8g2.drawPixel(i, j);
		// 	}
		// }
		// MPU6050_Read_Accel();
		// MPU6050_Read_Gyro();
		// MPU6050_Read_Temp();
		// sprintf(str[0],"Ax=%d.%d,Ay=%d.%d,Az=%d.%d\r\n",A(Ax), B(Ax), A(Ay), B(Ay), A(Az), B(Az));
		// sprintf(str[1],"Gx=%d.%d,Gy=%d.%d,Gz=%d.%d\r\n",A(Gx), B(Gx), A(Gy), B(Gy), A(Gz), B(Gz));
		// sprintf (str[2],"Temperature=%d.%d,\r\n",A(Temp), B(Temp));
		// u8g2.drawStr(0,10,str[0]);
		// u8g2.drawStr(0,20,str[1]);
		// u8g2.drawStr(0,30,(str[1]+20));
		// u8g2.drawStr(0,40,str[2]);
		// HAL_UART_Transmit(&huart2, (uint8_t*)str[0], strlen(str[0]),1000);
		// HAL_UART_Transmit(&huart2, (uint8_t*)str[1], strlen(str[1]),1000);
		// HAL_UART_Transmit(&huart2, (uint8_t*)str[2], strlen(str[2]),1000);
		// u8g2_SetContrast(&u8g22, 255);
		// u8g22.clearBuffer();
		// for (int i = 0; i < 128; i++) {
		// 	for (int j = 0; j < 128; j++) {
		// 		if ((i^j)%2)
		// 			u8g22.drawPixel(i, j);
		// 	}
		// }
			// u8g2.drawLine(64, 20, 128, 20);
			// u8g2.drawLine(64, 20, 64, 44);
			// u8g2.drawLine(128,20, 128,44);
			// u8g2.drawLine(64,44,128,44);
		// 	u8g2.drawStr(66,38, "WARNING");
	// 	const int len = 512;
		// for (int i = 0; i < 20; i++) startpos[i] = 0;
		// for (int i = 0; i < len; i++) str[i] = 0;
		// HAL_UART_Receive(&huart1, (uint8_t*)str, len, 300);
		// int j = 1;
		// for (int i = 0; i < len; i++) {
		// 	if (str[i] == '\r' && str[i+1] == '\n') {
		// 		str[i] = str[i+1] = '\0';
		// 		startpos[j++] = i+2;
		// 	}
		// }
		// if (j > 2)
	// 	for (int i = 0; i < 10; i ++) {
	// 		if (str[i][0] == '$')
	// 		u8g2.drawStr(0, 10*(i+1), str[i]);
	// 	}
		// u8g2.drawStr(0, 10, str);
		// u8g2.drawStr(0, 20, str+len/4+1);
		// u8g2.drawStr(0, 30, str+len/2+1);
		// u8g2.drawStr(0, 40, str+3*len/4+1);
		// 	// u8g2.drawRBox()
		// 	// u8g2.drawBox(64, 20, 64, 24);
		// }
		// u8g2.clearLine()
		// u8g2.drawStr(10, 20, "Hello World");
		// u8g2.sendBuffer();
		// u8g22.sendBuffer();

	// HAL_UART_Receive_IT(&huart2, (uint8_t *)&uart1_rxbuf, 1);
	// HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,GPIO_PIN_RESET);
		// HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);
		// HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);
		// HAL_Delay(500);
	}

}

// void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size) {
// 	static int in = 0;

// 	// if (huart -> Instance == USART1) {
// 	// 	HAL_UART_Transmit(&huart1, uart1_rxbuf, size, 0xff);
// 	// 	HAL_UARTEx_ReceiveToIdle_IT(&huart1, uart1_rxbuf, 1024);
// 	// }
// 	if (huart -> Instance == USART1) {
// 		HAL_UART_Transmit(&huart1, uart1_rxbuf, size,0xff);
// 		ind = 0;
// 		in = 1;
// 		// startpos[0] = 0;
// 		for (int i = 0; i < size; i++) {
// 			if (uart1_rxbuf[i] == '\r' && uart1_rxbuf[i+1] == '\n') {
// 				uart1_rxbuf[i] = '\0';
// 				ind ++;
// 				startpos[in++] = i + 2;
// 				i ++;
// 			}
// 		}
// 		HAL_UARTEx_ReceiveToIdle_DMA(&huart1, uart1_rxbuf, 1024);
// 		// __HAL_DMA_DISABLE_IT(&hdma_usart1_rx, DMA_IT_HT);  // 关闭DMA hite
// 	}
// }
/*
void USAR_UART_IDLECallback(UART_HandleTypeDef *huart) {
    HAL_UART_DMAStop(&huart1);                                                     //停止本次DMA传输

    uint16_t data_length  = BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);   //计算接收到的数据长度

    // printf("Receive Data(length = %d): ",data_length);
    HAL_UART_Transmit(&huart1,uart1_rxbuf,data_length,0x200);                     //测试函数：将接收到的数据打印出去
    // printf("\r\n");

    memset(uart1_rxbuf,0,data_length);                                            //清零接收缓冲区
    data_length = 0;
    HAL_UART_Receive_DMA(&huart1, (uint8_t*)uart1_rxbuf, 1024);                    //重启开始DMA传输 每次255字节数据
}
void USER_UART_IRQHandler(UART_HandleTypeDef *huart) {
    if(USART1 == huart1.Instance) {                                  //判断是否是串口1（！此处应写(huart->Instance == USART1)
        if(RESET != __HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE)) {  //判断是否是空闲中断
            __HAL_UART_CLEAR_IDLEFLAG(&huart1);                      //清除空闲中断标志（否则会一直不断进入中断）
            // printf("\r\nUART1 Idle IQR Detected\r\n");
            USAR_UART_IDLECallback(huart);                           //调用中断处理函数
        }
    }
}*/
// void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
// 	static int in = 0;
// 	static bool cr = false;
// 	static int ind = 0;
// 	HAL_UART_Transmit(&huart2, uart1_rxbuf, 1, 100);    // 把收到的字节原样发送出去
	// if (huart == &huart1) {
	// 	if (uart1_rxbuf[0] == '$') {
	// 		ind = 0;
	// 	}
	// 	str[in][ind] = uart1_rxbuf[0];
	// 	// HAL_UART_Transmit(&huart1, (uint8_t*)&str[in][ind],1,100);
	// 	if (uart1_rxbuf[0] == '\r') {
	// 		str[in][ind] = '\0';
	// 		cr = true;
	// 	}
	// 	if (cr && uart1_rxbuf[0] == '\n') {
	// 		str[in][ind] = '\0';
	// 		if (str[in][4] == 'G' && str[in][5] == 'A') {
	// 			for (int i = 0; i < ind; i++) {
	// 				str[0][i] = str[in][i];
	// 			}
	// 			in = 0;
	// 			ind = 0;
	// 		}
	// 		cr = false;
	// 		in ++;
	// 		ind = 0;
	// 	}
	// 	ind ++;
	// 	if (in >= 10) in = 0;
	// }
// 	HAL_UART_Receive_IT(&huart2, (uint8_t *)&uart1_rxbuf, 1);
// }

// void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
// 	static int adc_read_counter = 0;
// 	static double adc_sum = 0.0;
// 	uint16_t ADC_Value = 0;
// 	static int dac_index = 0;
// 	// static uint32_t last_pwm_counter_capture = 0;
// 	if (htim == (&htim6)) {
// 		for (int ii = 0; ii < sizeof(c0); ii++) {
// 			HAL_ADC_Start(&hadc1);
// 			HAL_ADC_PollForConversion(&hadc1, 50);
// 			if (HAL_IS_BIT_SET(HAL_ADC_GetState(&hadc1), HAL_ADC_STATE_REG_EOC)) {
// 				c0[c0i ++] = HAL_ADC_GetValue(&hadc1);
// 			}
// 			HAL_ADC_Start(&hadc1);
// 			HAL_ADC_PollForConversion(&hadc1, 50);
// 			if (HAL_IS_BIT_SET(HAL_ADC_GetState(&hadc1), HAL_ADC_STATE_REG_EOC)) {
// 				c1[c1i ++] = HAL_ADC_GetValue(&hadc1);
// 			}
// 		}
// 		adc_is_compelete = true;
// 	}
// }