#ifndef __TBZ_MOTOR_H_
#define __TBZ_MOTOR_H_

#include <8052.h>

#ifdef __TBZ_BINARY_H_
#include "binary.h"
#endif


/*
* 首先我们来看一下28BYJ-48步进电机名称的来历。
? 28: 步进电机的有效最大外径是28毫米
? B:  表示是步进电机
? Y:  表示是永磁式
? J:  表示是减速型（减速比1:64）
? 48: 表示四相八拍

** 换句话说，28BYJ-48的含义为外径28毫米四相八拍式永磁减速型步进电机。是不是有点乱?别急，我们一点点看。


***************************************************************************************************


** 跳线接到电机上时,此时 P1.0-3 控制着电机上的四个电磁铁,0使其导通
** 其中的 转子就会被吸引到对应的位置上,然后我们就可以通过电磁铁导通的顺序
** 来控制电机朝什么方向转,转速为多少,每一个脉冲都会使转子转过一定角度(使转子和电磁铁相互吸引)
** 但是因为这个开发板上的还是一个减速步进电机(小齿轮带动大齿轮)力矩大,速度慢
*/

// oh shit, 我之前把这个设为了 const, 难怪怎么不能 reverse

/**
 * @brief 电机转动时序
 */
unsigned char beatCode [] = {
#ifdef __TBZ_BINARY_H_
	// 八拍(电机转动速度较慢,精度较高,力矩较大)
	// B1110, B1100, B1101, B1001, B1011, B0011, B0111, B0110
	// 逆时针单四拍(电机转动速度较快,精度较低,力矩较小)
	// B1110, B1101, B1011, B0111,
	// 逆时针单四拍(电机转动速度较快,精度较低,力矩较小)
	B0111, B1011, B1101, B1110
#else
	0x0e, 0x0c, 0x0d, 0x09, 0x0b, 0x03, 0x07, 0x06
#endif
};

/**
 * @brief 让电机的马达按照 beatCode 步进一次
 */
void stepMottor () {
	static char i = 0;
	P1 &= 0xf0;
	P1 |= beatCode [i];
	i = (i+1) % sizeof (beatCode);
}

#endif