/* CRC16 计算函数，ptr-数据指针，len-数据长度，返回值-计算出的 CRC16 数值 */
unsigned int GetCRC16(unsigned char *ptr, unsigned char len) {
	unsigned int index;
	unsigned char crch = 0xFF;	 //高 CRC 字节
	unsigned char crcl = 0xFF;	 //低 CRC 字节
	unsigned char code TabH[] = {//CRC 高位字节值表
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
								 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40};
	unsigned char code TabL[] = {//CRC 低位字节值表
		0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
		0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
		0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
		0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
		0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
		0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
		0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
		0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
		0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
		0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
		0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
		0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
		0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
		0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
		0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
		0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
		0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
		0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
		0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
		0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
		0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
		0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
		0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
		0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
		0x43, 0x83, 0x41, 0x81, 0x80, 0x40};
	while (len--) {//计算指定长度的 CRC
		index = crch ^ *ptr++;
		crch = crcl ^ TabH[index];
		crcl = TabL[index];
	}
	return ((crch << 8) | crcl);
}

/* 串口动作函数，根据接收到的命令帧执行响应的动作
buf-接收到的命令帧指针，len-命令帧长度 */
void UartAction(unsigned char *buf, unsigned char len) {
	unsigned char i;
	unsigned char cnt;
	unsigned char str[4];
	unsigned int crc;
	unsigned char crch, crcl;
	if (buf[0] != 0x01) {//本例中的本机地址设定为 0x01，
						//如数据帧中的地址字节与本机地址不符，
		return;			//则直接退出，即丢弃本帧数据不做任何处理
	}
	//地址相符时，再对本帧数据进行校验
	crc = GetCRC16(buf, len - 2); //计算 CRC 校验值
	crch = crc >> 8;
	crcl = crc & 0xFF;
	if ((buf[len - 2] != crch) || (buf[len - 1] != crcl)) {
		return; //如 CRC 校验不符时直接退出
	}
	//地址和校验字均相符后，解析功能码，执行相关操作
	switch (buf[1]) {
		case 0x03:									  //读取一个或连续的寄存器
		if ((buf[2] == 0x00) && (buf[3] <= 0x05)) {//只支持 0x0000～0x0005
			if (buf[3] <= 0x04) {
				i = buf[3];		  //提取寄存器地址
				cnt = buf[5];	  //提取待读取的寄存器数量
				buf[2] = cnt * 2; //读取数据的字节数，为寄存器数*2
				len = 3;		  //帧前部已有地址、功能码、字节数共 3 个字节
				while (cnt--) {
					buf[len++] = 0x00;			//寄存器高字节补 0
					buf[len++] = regGroup[i++]; //寄存器低字节
				}
			} else {//地址 0x05 为蜂鸣器状态
				buf[2] = 2; //读取数据的字节数
				buf[3] = 0x00;
				buf[4] = flagBuzzOn;
				len = 5;
			}
			break;
		} else {//寄存器地址不被支持时，返回错误码
			buf[1] = 0x83; //功能码最高位置 1
			buf[2] = 0x02; //设置异常码为 02-无效地址
			len = 3;
			break;
		}
		case 0x06:									  //写入单个寄存器
		if ((buf[2] == 0x00) && (buf[3] <= 0x05)) {//只支持 0x0000～0x0005
			if (buf[3] <= 0x04) {
				i = buf[3];				//提取寄存器地址
				regGroup[i] = buf[5];	//保存寄存器数据
				cnt = regGroup[i] >> 4; //显示到液晶上
				if (cnt >= 0xA) str[0] = cnt - 0xA + 'A';
				else            str[0] = cnt + '0';
				cnt = regGroup[i] & 0x0F;
				if (cnt >= 0xA) str[1] = cnt - 0xA + 'A';
				else            str[1] = cnt + '0';
				str[2] = '\0';
				LcdShowStr(i * 3, 0, str);
			} else {//地址 0x05 为蜂鸣器状态
				flagBuzzOn = (bit)buf[5]; //寄存器值转为蜂鸣器的开关
			}
			len -= 2; //长度-2 以重新计算 CRC 并返回原帧
			break;
		} else {//寄存器地址不被支持时，返回错误码
			buf[1] = 0x86; //功能码最高位置 1
			buf[2] = 0x02; //设置异常码为 02-无效地址
			len = 3;
			break;
		}
	default:			//其它不支持的功能码
		buf[1] |= 0x80; //功能码最高位置 1
		buf[2] = 0x01;	//设置异常码为 01-无效功能
		len = 3;
		break;
	}
	crc = GetCRC16(buf, len); //计算返回帧的 CRC 校验值
	buf[len++] = crc >> 8;	  //CRC 高字节
	buf[len++] = crc & 0xFF;  //CRC 低字节
	UartWrite(buf, len);	  //发送返回帧
}
/* 配置并启动 T0，ms-T0 定时时间 */
void ConfigTimer0(unsigned int ms) {
	unsigned long tmp;				  //临时变量
	tmp = 11059200 / 12;			  //定时器计数频率
	tmp = (tmp * ms) / 1000;		  //计算所需的计数值
	tmp = 65536 - tmp;				  //计算定时器重载值
	tmp = tmp + 33;					  //补偿中断响应延时造成的误差
	T0RH = (unsigned char)(tmp >> 8); //定时器重载值拆分为高低字节
	T0RL = (unsigned char)tmp;
	TMOD &= 0xF0; //清零 T0 的控制位
	TMOD |= 0x01; //配置 T0 为模式 1
	TH0 = T0RH;	  //加载 T0 重载值
	TL0 = T0RL;
	ET0 = 1; //使能 T0 中断
	TR0 = 1; //启动 T0
}
/* T0 中断服务函数，执行串口接收监控和蜂鸣器驱动 */
void InterruptTimer0() interrupt 1 {
	TH0 = T0RH; //重新加载重载值
	TL0 = T0RL;
	if (flagBuzzOn) //执行蜂鸣器鸣叫或关闭
		BUZZ = ~BUZZ;
	else
		BUZZ = 1;
	UartRxMonitor(1); //串口接收监控
}