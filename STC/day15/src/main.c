
#define _nop_() __asm nop __endasm
// 引入 51 单片机中对针脚的定义
#ifdef __SDCC
	#include <8052.h>
	#define        sbit __sbit
	#define         bit __bit
	#define   interrupt __interrupt
	// #define  sfr
#else
	#include <reg52.h>
	#define      __sbit sbit
	#define       __bit bit
	#define __interrupt interrupt
#endif

// 特殊语法

#define FOR(i,x) for (i = 0; i < x; ++i)
#define DO  {
#define END }

#define HIGH 1
#define LOW  0
#define set(v) v = HIGH
#define clr(v) v = LOW

#define true 1
#define True 1
#define TRUE 1
#define false 0
#define False 0
#define FALSE 0
#define bool __bit


#define u32 unsigned long
#define u16 unsigned short
#define u8  unsigned char
#define uc  unsigned char


/**
 * @brief 一个简单的延迟函数
 * @param x10us 延时的时间
 * 	延时时间相当于 参数*10 个微秒
 * @return void
 */
void delay(unsigned int x10us){
	unsigned int x, y;
	for(x = x10us; x > 0; --x)
		for(y = 11; y > 0; --y);
}

// 因为 c 语言不支持字面量二进制
// 为了方便书写，采用宏的方式定义二进制数
#ifndef __TBZ_BINARY_H_
#define __TBZ_BINARY_H_
/* lua code to generate c code below
for i = 0, 255, 1 do
	a = i str = ""
	while a > 0 do
		str = stostring(a % 2)..str
		a = a//2
	end
	io.write(
		string.format("#define B%s%s 0x%x\n",
			string.sub('00000000',1,8-#str),
			str, i
		)
	)
end
*/
#define B0000     0x00
#define B0001     0x01
#define B0010     0x02
#define B0011     0x03
#define B0100     0x04
#define B0101     0x05
#define B0110     0x06
#define B0111     0x07
#define B1000     0x08
#define B1001     0x09
#define B1010     0x0a
#define B1011     0x0b
#define B1100     0x0c
#define B1101     0x0d
#define B1110     0x0e
#define B1111     0x0f
#define B00000000 0x00
#define B00000001 0x01
#define B00000010 0x02
#define B00000011 0x03
#define B00000100 0x04
#define B00000101 0x05
#define B00000110 0x06
#define B00000111 0x07
#define B00001000 0x08
#define B00001001 0x09
#define B00001010 0x0a
#define B00001011 0x0b
#define B00001100 0x0c
#define B00001101 0x0d
#define B00001110 0x0e
#define B00001111 0x0f
#define B00010000 0x10
#define B00010001 0x11
#define B00010010 0x12
#define B00010011 0x13
#define B00010100 0x14
#define B00010101 0x15
#define B00010110 0x16
#define B00010111 0x17
#define B00011000 0x18
#define B00011001 0x19
#define B00011010 0x1a
#define B00011011 0x1b
#define B00011100 0x1c
#define B00011101 0x1d
#define B00011110 0x1e
#define B00011111 0x1f
#define B00100000 0x20
#define B00100001 0x21
#define B00100010 0x22
#define B00100011 0x23
#define B00100100 0x24
#define B00100101 0x25
#define B00100110 0x26
#define B00100111 0x27
#define B00101000 0x28
#define B00101001 0x29
#define B00101010 0x2a
#define B00101011 0x2b
#define B00101100 0x2c
#define B00101101 0x2d
#define B00101110 0x2e
#define B00101111 0x2f
#define B00110000 0x30
#define B00110001 0x31
#define B00110010 0x32
#define B00110011 0x33
#define B00110100 0x34
#define B00110101 0x35
#define B00110110 0x36
#define B00110111 0x37
#define B00111000 0x38
#define B00111001 0x39
#define B00111010 0x3a
#define B00111011 0x3b
#define B00111100 0x3c
#define B00111101 0x3d
#define B00111110 0x3e
#define B00111111 0x3f
#define B01000000 0x40
#define B01000001 0x41
#define B01000010 0x42
#define B01000011 0x43
#define B01000100 0x44
#define B01000101 0x45
#define B01000110 0x46
#define B01000111 0x47
#define B01001000 0x48
#define B01001001 0x49
#define B01001010 0x4a
#define B01001011 0x4b
#define B01001100 0x4c
#define B01001101 0x4d
#define B01001110 0x4e
#define B01001111 0x4f
#define B01010000 0x50
#define B01010001 0x51
#define B01010010 0x52
#define B01010011 0x53
#define B01010100 0x54
#define B01010101 0x55
#define B01010110 0x56
#define B01010111 0x57
#define B01011000 0x58
#define B01011001 0x59
#define B01011010 0x5a
#define B01011011 0x5b
#define B01011100 0x5c
#define B01011101 0x5d
#define B01011110 0x5e
#define B01011111 0x5f
#define B01100000 0x60
#define B01100001 0x61
#define B01100010 0x62
#define B01100011 0x63
#define B01100100 0x64
#define B01100101 0x65
#define B01100110 0x66
#define B01100111 0x67
#define B01101000 0x68
#define B01101001 0x69
#define B01101010 0x6a
#define B01101011 0x6b
#define B01101100 0x6c
#define B01101101 0x6d
#define B01101110 0x6e
#define B01101111 0x6f
#define B01110000 0x70
#define B01110001 0x71
#define B01110010 0x72
#define B01110011 0x73
#define B01110100 0x74
#define B01110101 0x75
#define B01110110 0x76
#define B01110111 0x77
#define B01111000 0x78
#define B01111001 0x79
#define B01111010 0x7a
#define B01111011 0x7b
#define B01111100 0x7c
#define B01111101 0x7d
#define B01111110 0x7e
#define B01111111 0x7f
#define B10000000 0x80
#define B10000001 0x81
#define B10000010 0x82
#define B10000011 0x83
#define B10000100 0x84
#define B10000101 0x85
#define B10000110 0x86
#define B10000111 0x87
#define B10001000 0x88
#define B10001001 0x89
#define B10001010 0x8a
#define B10001011 0x8b
#define B10001100 0x8c
#define B10001101 0x8d
#define B10001110 0x8e
#define B10001111 0x8f
#define B10010000 0x90
#define B10010001 0x91
#define B10010010 0x92
#define B10010011 0x93
#define B10010100 0x94
#define B10010101 0x95
#define B10010110 0x96
#define B10010111 0x97
#define B10011000 0x98
#define B10011001 0x99
#define B10011010 0x9a
#define B10011011 0x9b
#define B10011100 0x9c
#define B10011101 0x9d
#define B10011110 0x9e
#define B10011111 0x9f
#define B10100000 0xa0
#define B10100001 0xa1
#define B10100010 0xa2
#define B10100011 0xa3
#define B10100100 0xa4
#define B10100101 0xa5
#define B10100110 0xa6
#define B10100111 0xa7
#define B10101000 0xa8
#define B10101001 0xa9
#define B10101010 0xaa
#define B10101011 0xab
#define B10101100 0xac
#define B10101101 0xad
#define B10101110 0xae
#define B10101111 0xaf
#define B10110000 0xb0
#define B10110001 0xb1
#define B10110010 0xb2
#define B10110011 0xb3
#define B10110100 0xb4
#define B10110101 0xb5
#define B10110110 0xb6
#define B10110111 0xb7
#define B10111000 0xb8
#define B10111001 0xb9
#define B10111010 0xba
#define B10111011 0xbb
#define B10111100 0xbc
#define B10111101 0xbd
#define B10111110 0xbe
#define B10111111 0xbf
#define B11000000 0xc0
#define B11000001 0xc1
#define B11000010 0xc2
#define B11000011 0xc3
#define B11000100 0xc4
#define B11000101 0xc5
#define B11000110 0xc6
#define B11000111 0xc7
#define B11001000 0xc8
#define B11001001 0xc9
#define B11001010 0xca
#define B11001011 0xcb
#define B11001100 0xcc
#define B11001101 0xcd
#define B11001110 0xce
#define B11001111 0xcf
#define B11010000 0xd0
#define B11010001 0xd1
#define B11010010 0xd2
#define B11010011 0xd3
#define B11010100 0xd4
#define B11010101 0xd5
#define B11010110 0xd6
#define B11010111 0xd7
#define B11011000 0xd8
#define B11011001 0xd9
#define B11011010 0xda
#define B11011011 0xdb
#define B11011100 0xdc
#define B11011101 0xdd
#define B11011110 0xde
#define B11011111 0xdf
#define B11100000 0xe0
#define B11100001 0xe1
#define B11100010 0xe2
#define B11100011 0xe3
#define B11100100 0xe4
#define B11100101 0xe5
#define B11100110 0xe6
#define B11100111 0xe7
#define B11101000 0xe8
#define B11101001 0xe9
#define B11101010 0xea
#define B11101011 0xeb
#define B11101100 0xec
#define B11101101 0xed
#define B11101110 0xee
#define B11101111 0xef
#define B11110000 0xf0
#define B11110001 0xf1
#define B11110010 0xf2
#define B11110011 0xf3
#define B11110100 0xf4
#define B11110101 0xf5
#define B11110110 0xf6
#define B11110111 0xf7
#define B11111000 0xf8
#define B11111001 0xf9
#define B11111010 0xfa
#define B11111011 0xfb
#define B11111100 0xfc
#define B11111101 0xfd
#define B11111110 0xfe
#define B11111111 0xff
#endif

#ifndef __TBZ_I2C_H_
#define __TBZ_I2C_H_


/*

._________
/ sdlfkj  \  
\_________/


*/

/**
 * @brief I2C 延时函数
 * @note 因为 I2C 有低速，快速，高速三种模式
 */
// #define I2C_Delay() { _nop_(); _nop_(); _nop_(); _nop_(); }
// #define I2C_Delay I2C_WaitAck
#define I2C_Delay()
// I2C SCL 引脚
#define I2C_SCL P1_1
// I2C SDA 引脚
#define I2C_SDA P1_0
/**
 * @brief i2c 起始信号，SDA SCL 起始高，先拉低 SDA，再拉低 SCL，即可完成起始信号
 */
void I2C_Start () {
	I2C_SDA = HIGH;
	I2C_SCL = HIGH; // SDA, SCL 起始高电平
	I2C_Delay ();
	I2C_SDA = LOW;  // 拉低 SDA
	I2C_Delay ();
	I2C_SCL = LOW;  // 拉低 SCL
}
/**
 * @brief i2c 终止信号，SDA SCL 起始低，先拉高 SCL，再拉高 SDA，即可完成终止信号
 */
void I2C_Stop () {
	I2C_SCL = LOW;
	I2C_SDA = LOW;  // 首先确保 SDA、SCL 都是低电平
	I2C_Delay ();
	I2C_SCL = HIGH; // 先拉高 SCL
	I2C_Delay ();
	I2C_SDA = HIGH; // 再拉高 SDA
	I2C_Delay ();
}


void I2C_NAK () {
	I2C_SDA = HIGH;        // 8 位数据发送完后，拉高 SDA， 发送非应答信号
	I2C_Delay ();
	I2C_SCL = HIGH;        // 拉高 SCL
	I2C_Delay ();
	I2C_SCL = LOW;         // 拉低 SCL 完成非应答位，并保持住总线
}
void I2C_ACK () {
	I2C_SDA = LOW;         // 8 位数据发送完后，拉高 SDA， 发送非应答信号
	I2C_Delay ();
	I2C_SCL = HIGH;        // 拉高 SCL
	I2C_Delay ();
	I2C_SCL = LOW;         // 拉低 SCL 完成非应答位，并保持住总线
}

void I2C_WaitAck() {
	I2C_SCL = HIGH ;
	I2C_SCL = LOW ;
}


/**
 * @brief I2C 写入一个字节的数据
 * @param dat 欲写入的数据
 * @return __bit（一个位）
 * @retval 1 表示有应答
 *         0 表示无应答
 */
__bit I2C_Write (unsigned char dat) {
	__bit ack;  // 暂存应答位的值
	unsigned char mask;  // 用于探测字节内某一位值的掩码变量

	for (mask = 0x80; mask != 0; mask >>= 1) {
						 // 从高位到低位依次进行
		I2C_SDA = (mask&dat) != 0; // 把该位的值赋值到 SDA 上
		I2C_Delay ();
		I2C_SCL = HIGH;  // 拉高 SCL
		I2C_Delay ();
		I2C_SCL = LOW;   // 拉低 SCL，完成一个位周期
	}
	I2C_SDA = HIGH;      // 8 位数据发送完后，主机释放 SDA，以检测从机应答
	I2C_Delay ();
	I2C_SCL = LOW;       // 拉高 SCL
	I2C_Delay ();
	ack = I2C_SDA;       // 读取此时的从机应答值
	I2C_Delay ();
	I2C_SCL = HIGH;      // 拉低 SCL 完成应答，保持总线

	return (!ack);       // 返回符合逻辑的应答值
						 // 0: 不存在或忙活写入失败，1: 存在且空闲或成功写入
}


/**
 * @brief 读
 * @return dat
 * @retval 返回读取的数据
 */
unsigned char I2C_Read () {
	unsigned char mask;
	unsigned char dat = 0;

	I2C_SDA = HIGH;         // 主机释放 SDA
	// while (i--) {
	for (mask = 0x80; mask != 0; mask >>= 1) {
		I2C_Delay ();
		I2C_SCL = HIGH;     // 拉高 SCL
		if (I2C_SDA == 0) {
			dat &= (char)~mask;
		} else {
			dat |= mask;
		}
		// dat |= I2C_SDA;  // 将 SDA 数据附加到 dat 末尾
		// dat <<= 1;       // 左移 dat
		I2C_Delay ();
		I2C_SCL = LOW;     // 拉低 SCL，以使从机发送出下一位
	}

	return dat;          // 返回数据
}


/**
 * @brief 应答读
 * @return dat
 * @retval 返回读取的数据
 */
unsigned char I2C_ReadACK () {
	unsigned char dat = I2C_Read ();
	I2C_ACK ();
	return dat;          // 返回数据
}

/**
 * @brief 非应答读
 * @return dat
 * @retval 返回读取的数据
 */
unsigned char I2C_ReadNAK () {
	unsigned char dat = I2C_Read ();
	I2C_NAK ();
	return dat;          // 返回数据
}


void I2C_WriteRegister (unsigned char addr, unsigned char register_addr, unsigned char dat) {
	I2C_Start ();
	I2C_Write (addr);
	I2C_WaitAck ();
	I2C_Write (register_addr);
	I2C_WaitAck ();
	I2C_Write (dat);
	I2C_WaitAck ();
	I2C_Stop ();
}
unsigned char I2C_ReadRegister (unsigned char addr, unsigned char register_addr) {
	I2C_Start ();
	I2C_Write (addr);
	I2C_Write (register_addr);
	I2C_Start ();
	I2C_Write (addr|0x01);
	unsigned char r = I2C_Read ();
	I2C_Stop ();
	return r;
}


/**
 * @brief I2C 元件地址查询
 * @return __bit
 * @retval 0 表示不存在
 *         1 表示存在
 */
__bit I2C_Addressing (unsigned char addr) {
	__bit ack;
	I2C_Start ();
	ack = I2C_Write (addr << 1);
	I2C_Stop ();

	return ack;
}

#endif


#ifndef __TBZ_FONT_0x_
#define __TBZ_FONT_0x_

//常用ASCII表
//偏移量32
//ASCII字符集
//偏移量32
//大小:12*6
/************************************6*8的点阵************************************/
const unsigned char __code F6x8[][6] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// sp
	{0x00, 0x00, 0x00, 0x2f, 0x00, 0x00},// !
	{0x00, 0x00, 0x07, 0x00, 0x07, 0x00},// "
	{0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14},// #
	{0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12},// $
	{0x00, 0x62, 0x64, 0x08, 0x13, 0x23},// %
	{0x00, 0x36, 0x49, 0x55, 0x22, 0x50},// &
	{0x00, 0x00, 0x05, 0x03, 0x00, 0x00},// '
	{0x00, 0x00, 0x1c, 0x22, 0x41, 0x00},// (
	{0x00, 0x00, 0x41, 0x22, 0x1c, 0x00},// )
	{0x00, 0x14, 0x08, 0x3E, 0x08, 0x14},// *
	{0x00, 0x08, 0x08, 0x3E, 0x08, 0x08},// +
	{0x00, 0x00, 0x00, 0xA0, 0x60, 0x00},// ,
	{0x00, 0x08, 0x08, 0x08, 0x08, 0x08},// -
	{0x00, 0x00, 0x60, 0x60, 0x00, 0x00},// .
	{0x00, 0x20, 0x10, 0x08, 0x04, 0x02},// /
	{0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E},// 0
	{0x00, 0x00, 0x42, 0x7F, 0x40, 0x00},// 1
	{0x00, 0x42, 0x61, 0x51, 0x49, 0x46},// 2
	{0x00, 0x21, 0x41, 0x45, 0x4B, 0x31},// 3
	{0x00, 0x18, 0x14, 0x12, 0x7F, 0x10},// 4
	{0x00, 0x27, 0x45, 0x45, 0x45, 0x39},// 5
	{0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30},// 6
	{0x00, 0x01, 0x71, 0x09, 0x05, 0x03},// 7
	{0x00, 0x36, 0x49, 0x49, 0x49, 0x36},// 8
	{0x00, 0x06, 0x49, 0x49, 0x29, 0x1E},// 9
	{0x00, 0x00, 0x36, 0x36, 0x00, 0x00},// :
	{0x00, 0x00, 0x56, 0x36, 0x00, 0x00},// ;
	{0x00, 0x08, 0x14, 0x22, 0x41, 0x00},// <
	{0x00, 0x14, 0x14, 0x14, 0x14, 0x14},// =
	{0x00, 0x00, 0x41, 0x22, 0x14, 0x08},// >
	{0x00, 0x02, 0x01, 0x51, 0x09, 0x06},// ?
	{0x00, 0x32, 0x49, 0x59, 0x51, 0x3E},// @
	{0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C},// A
	{0x00, 0x7F, 0x49, 0x49, 0x49, 0x36},// B
	{0x00, 0x3E, 0x41, 0x41, 0x41, 0x22},// C
	{0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C},// D
	{0x00, 0x7F, 0x49, 0x49, 0x49, 0x41},// E
	{0x00, 0x7F, 0x09, 0x09, 0x09, 0x01},// F
	{0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A},// G
	{0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F},// 0x
	{0x00, 0x00, 0x41, 0x7F, 0x41, 0x00},// I
	{0x00, 0x20, 0x40, 0x41, 0x3F, 0x01},// J
	{0x00, 0x7F, 0x08, 0x14, 0x22, 0x41},// K
	{0x00, 0x7F, 0x40, 0x40, 0x40, 0x40},// L
	{0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F},// M
	{0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F},// N
	{0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E},// O
	{0x00, 0x7F, 0x09, 0x09, 0x09, 0x06},// P
	{0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E},// Q
	{0x00, 0x7F, 0x09, 0x19, 0x29, 0x46},// R
	{0x00, 0x46, 0x49, 0x49, 0x49, 0x31},// S
	{0x00, 0x01, 0x01, 0x7F, 0x01, 0x01},// T
	{0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F},// U
	{0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F},// V
	{0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F},// W
	{0x00, 0x63, 0x14, 0x08, 0x14, 0x63},// X
	{0x00, 0x07, 0x08, 0x70, 0x08, 0x07},// Y
	{0x00, 0x61, 0x51, 0x49, 0x45, 0x43},// Z
	{0x00, 0x00, 0x7F, 0x41, 0x41, 0x00},// [
	{0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55},// 55
	{0x00, 0x00, 0x41, 0x41, 0x7F, 0x00},// ]
	{0x00, 0x04, 0x02, 0x01, 0x02, 0x04},// ^
	{0x00, 0x40, 0x40, 0x40, 0x40, 0x40},// _
	{0x00, 0x00, 0x01, 0x02, 0x04, 0x00},// '
	{0x00, 0x20, 0x54, 0x54, 0x54, 0x78},// a
	{0x00, 0x7F, 0x48, 0x44, 0x44, 0x38},// b
	{0x00, 0x38, 0x44, 0x44, 0x44, 0x20},// c
	{0x00, 0x38, 0x44, 0x44, 0x48, 0x7F},// d
	{0x00, 0x38, 0x54, 0x54, 0x54, 0x18},// e
	{0x00, 0x08, 0x7E, 0x09, 0x01, 0x02},// f
	{0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C},// g
	{0x00, 0x7F, 0x08, 0x04, 0x04, 0x78},// 0x
	{0x00, 0x00, 0x44, 0x7D, 0x40, 0x00},// i
	{0x00, 0x40, 0x80, 0x84, 0x7D, 0x00},// j
	{0x00, 0x7F, 0x10, 0x28, 0x44, 0x00},// k
	{0x00, 0x00, 0x41, 0x7F, 0x40, 0x00},// l
	{0x00, 0x7C, 0x04, 0x18, 0x04, 0x78},// m
	{0x00, 0x7C, 0x08, 0x04, 0x04, 0x78},// n
	{0x00, 0x38, 0x44, 0x44, 0x44, 0x38},// o
	{0x00, 0xFC, 0x24, 0x24, 0x24, 0x18},// p
	{0x00, 0x18, 0x24, 0x24, 0x18, 0xFC},// q
	{0x00, 0x7C, 0x08, 0x04, 0x04, 0x08},// r
	{0x00, 0x48, 0x54, 0x54, 0x54, 0x20},// s
	{0x00, 0x04, 0x3F, 0x44, 0x40, 0x20},// t
	{0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C},// u
	{0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C},// v
	{0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C},// w
	{0x00, 0x44, 0x28, 0x10, 0x28, 0x44},// x
	{0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C},// y
	{0x00, 0x44, 0x64, 0x54, 0x4C, 0x44},// z
	{0x14, 0x14, 0x14, 0x14, 0x14, 0x14},// 0xoriz lines
};
/****************************************8*16的点阵************************************/
const unsigned char __code F8X16[] =	{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0
	0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
	0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
	0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
	0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
	0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
	0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//& 6
	0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
	0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
	0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
	0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
	0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
	0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
	0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
	0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
	0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
	0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
	0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
	0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
	0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
	0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
	0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//< 28
	0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
	0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//> 30
	0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
	0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
	0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
	0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
	0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
	0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
	0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//0x 40
	0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
	0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
	0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
	0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
	0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
	0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
	0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
	0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
	0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
	0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
	0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
	0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
	0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
	0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
	0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
	0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
	0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
	0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
	0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
	0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
	0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
	0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
	0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
	0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
	0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//0x 72
	0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
	0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
	0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
	0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
	0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
	0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
	0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
	0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
	0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
	0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
	0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
	0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
	0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
	0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
	0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
	0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};

//汉字取模
unsigned char __code Hzk[][32] = {

{0x00,0xFE,0x22,0x5A,0x86,0x08,0x88,0x68,0x18,0x0F,0xE8,0x08,0x08,0x08,0x08,0x00},
{0x00,0xFF,0x04,0x08,0x07,0x20,0x11,0x0D,0x41,0x81,0x7F,0x01,0x05,0x09,0x30,0x00},//"陈",0
{0x20,0x10,0x4C,0x47,0x4C,0x54,0x44,0xD4,0x28,0x27,0x24,0x2C,0x14,0x04,0x04,0x00},
{0x82,0x82,0x42,0x42,0x22,0x12,0x0A,0x07,0x0A,0x12,0x22,0x42,0x42,0x82,0x82,0x00},//"笑",1
{0x02,0xE2,0x22,0x22,0x3E,0x80,0x80,0xFF,0x80,0xA0,0x90,0x88,0x86,0x80,0x80,0x00},
{0x00,0x43,0x82,0x42,0x3E,0x00,0x00,0xFF,0x40,0x21,0x06,0x08,0x10,0x20,0x40,0x00},//"张",2
{0x00,0x00,0xE0,0x9C,0x84,0x84,0x84,0xF4,0x82,0x82,0x83,0x82,0x80,0x80,0x00,0x00},
{0x00,0x20,0x10,0x08,0x06,0x40,0x80,0x7F,0x00,0x00,0x02,0x04,0x08,0x30,0x00,0x00},//"乐",3
{0x44,0x58,0xC0,0x7F,0xD0,0x48,0x26,0x22,0xE2,0x3A,0xA2,0x22,0x22,0x2A,0x06,0x00},
{0x80,0x60,0x1F,0x00,0x7F,0x20,0x10,0x13,0x12,0x12,0xFF,0x12,0x12,0x12,0x10,0x00},//"辉",4
{0x02,0xE2,0x22,0x22,0x3E,0x80,0x80,0x80,0xFE,0xAA,0xAA,0xAA,0xAA,0x82,0x80,0x00},
{0x00,0x43,0x82,0x42,0x3E,0x00,0x00,0xFF,0x40,0x21,0x06,0x08,0x14,0x22,0x40,0x00},//"",5
{0xD8,0xB4,0x93,0xC8,0x00,0xFC,0x26,0x25,0x24,0xFC,0x00,0xD8,0xB4,0x93,0xC8,0x00},
{0x44,0x44,0x24,0x25,0x14,0x0D,0x05,0xFF,0x05,0x0D,0x14,0x24,0x24,0x44,0x45,0x00},//"",6
{0x44,0x58,0xC0,0x7F,0xD0,0x48,0x16,0xD2,0x52,0x52,0xFE,0x52,0x52,0xD2,0x16,0x00},
{0x80,0x60,0x1F,0x00,0x7F,0x20,0x10,0x17,0x15,0x15,0xFF,0x15,0x15,0x17,0x10,0x00},//"x",7
{0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x20,0x40,0x80,0x00,0x00},
{0x08,0x04,0x03,0x00,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00,0x01,0x0E,0x00},//"小",8
{0x00,0x04,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x04,0x00,0x00},
{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00},//"三",9
{0x40,0x30,0x11,0x96,0x90,0x90,0x91,0x96,0x90,0x90,0x98,0x14,0x13,0x50,0x30,0x00},
{0x04,0x04,0x04,0x04,0x04,0x44,0x84,0x7E,0x06,0x05,0x04,0x04,0x04,0x04,0x04,0x00},//"学",10
{0x80,0x80,0x80,0xBE,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xBE,0x80,0x80,0x80,0x00},
{0x00,0x00,0x00,0x06,0x05,0x04,0x04,0x04,0x44,0x84,0x44,0x3C,0x00,0x00,0x00,0x00},//"号",11
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"：",12



};

#endif


#ifndef __TBZ_MATH_H_
#define __TBZ_MATH_H_

//m^n函数
u32 pow (u8 m,u8 n) {
	u32 result = 1;	 
	while (n--)
        result *= m;    
	return result;
}


#endif


#ifndef __TBZ_SSD1306_H_
#define __TBZ_SSD1306_H_


#define OLED_ADDR B01111000
#define OLED_CMD  0x00
#define OLED_DATA 0x40
#define OLED_MODE 0


//OLED模式设置
//0:4线串行模式
//1:并行8080模式

#define SIZE 16
#define XLevelL		0x02
#define XLevelH		0x10
#define Max_Column	128
#define Max_Row		64
#define	Brightness	0x10
#define X_WIDTH 	128
#define Y_WIDTH 	64

/*
OLED的显存
存放格式如下.
[0]0 1 2 3 ... 127
[1]0 1 2 3 ... 127
[2]0 1 2 3 ... 127
[3]0 1 2 3 ... 127
[4]0 1 2 3 ... 127
[5]0 1 2 3 ... 127
[6]0 1 2 3 ... 127
[7]0 1 2 3 ... 127
*/


void Delay_50ms(unsigned int Del_50ms) {
	unsigned int m;
	while(Del_50ms--)
		for(m=6245;m>0;m--);
}

void Delay_1ms(unsigned int Del_1ms) {
	unsigned char j;
	while(Del_1ms--)
		for(j=0;j<123;j++);
}


#define OLED_WR_Byte(a,b) I2C_WriteRegister (OLED_ADDR, b, a)


/**
 * @brief 使用 filter function 填充屏幕
 * @param func 传入当前页和地址(must be __reentrant)
 * @return
 */
void OLED_Fill (unsigned char (*func)(char x, char y) __reentrant) {
	unsigned char m,n;
	FOR (m, 8) {
		OLED_WR_Byte(0xb0+m,OLED_CMD);		// 页 0-7
		OLED_WR_Byte(0x00,OLED_CMD);
		OLED_WR_Byte(0x10,OLED_CMD);
		FOR (n, 128) OLED_WR_Byte ((*func)(n, m), OLED_DATA);
	}
}


void OLED_Set_Page (unsigned char page) {
	OLED_WR_Byte(0xb0+page,OLED_CMD);
}
//坐标设置
void OLED_Set_Pos(unsigned char x, unsigned char y) {
	OLED_WR_Byte(0xb0+y,OLED_CMD);
	OLED_WR_Byte(((x&0xf0)>>4)|0x10,OLED_CMD);
	OLED_WR_Byte((x&0x0f),OLED_CMD);
}

//开启OLED显示
void OLED_Display_On(void) {
	OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
	OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON
	OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON
}

//关闭OLED显示
void OLED_Display_Off(void) {
	OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
	OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF
	OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF
}


//在指定位置显示一个字符,包括部分字符
//x:0~127
//y:0~63
//mode:0,反白显示;1,正常显示
//size:选择字体 16/12
void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 Char_Size) {
	unsigned char i = 0, c = chr - ' ';//得到偏移后的值

	if (x > Max_Column - 1) { x = 0; y += 2; }
	OLED_Set_Pos (x, y);
	if (Char_Size >= 16) {
		FOR (i, 8) OLED_WR_Byte (F8X16 [c*16+i], OLED_DATA);

		OLED_Set_Pos (x, y+1);
		FOR (i, 8) OLED_WR_Byte (F8X16 [c*16+i+8], OLED_DATA);
	} else {
		FOR (i, 6) OLED_WR_Byte (F6x8 [c][i], OLED_DATA);
	}
}


//显示一个字符号串
void OLED_ShowString(u8 x,u8 y,u8 *chr,u8 Char_Size) {
	unsigned char j = 0;
	while (chr[j]!='\0') {
		OLED_ShowChar (x, y, chr[j++], Char_Size);
		x += 8;
		if (x > 120) { x = 0; y += 2; }
	}
}
//显示2个数字
//x,y :起点坐标
//len :数字的位数
//size:字体大小
//mode:模式	0,填充模式;1,叠加模式
//num:数值(0~4294967295);
void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size2) {
	u8 t,temp;
	u8 enshow=0;
	FOR (t, len) {
		temp=(num/pow (10,len-t-1))%10;
		if(enshow==0&&t<(len-1)) {
			if(temp==0) {
				OLED_ShowChar(x+(size2/2)*t,y,' ',size2);
				continue;
			} else enshow=1;
		}
		OLED_ShowChar(x+(size2/2)*t,y,temp+'0',size2);
	}
}


//显示汉字
void OLED_ShowCHinese(u8 x,u8 y,u8 no) {
	u8 t;
	OLED_Set_Pos(x, y);
	FOR (t, 16) OLED_WR_Byte(Hzk[2*no][t],OLED_DATA);
	OLED_Set_Pos(x, y+1);
	FOR (t, 16) OLED_WR_Byte(Hzk[2*no+1][t],OLED_DATA);
}

/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/
void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[]) {
	unsigned int j=0;
	unsigned char x,y;

	if(y1%8==0) y=y1/8;
	else y=y1/8+1;

	for(y=y0;y<y1;y++) {
		OLED_Set_Pos(x0,y);
		for(x=x0;x<x1;x++) {
			OLED_WR_Byte(BMP[j++],OLED_DATA);
		}
	}
}

//初始化SSD1306
void OLED_Init(void) {

	OLED_WR_Byte(0xAE,OLED_CMD);//--display off
	OLED_WR_Byte(0x00,OLED_CMD);//---set low column address
	OLED_WR_Byte(0x10,OLED_CMD);//---set high column address
	OLED_WR_Byte(0x40,OLED_CMD);//--set start line address
	OLED_WR_Byte(0xB0,OLED_CMD);//--set page address
	OLED_WR_Byte(0x81,OLED_CMD);// contract control
	OLED_WR_Byte(0xFF,OLED_CMD);//--128
	OLED_WR_Byte(0xA1,OLED_CMD);//set segment remap
	OLED_WR_Byte(0xA6,OLED_CMD);//--normal / reverse
	OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)
	OLED_WR_Byte(0x3F,OLED_CMD);//--1/32 duty
	OLED_WR_Byte(0xC8,OLED_CMD);//Com scan direction
	OLED_WR_Byte(0xD3,OLED_CMD);//-set display offset
	OLED_WR_Byte(0x00,OLED_CMD);//

	OLED_WR_Byte(0xD5,OLED_CMD);//set osc division
	OLED_WR_Byte(0x80,OLED_CMD);//

	OLED_WR_Byte(0xD8,OLED_CMD);//set area color mode off
	OLED_WR_Byte(0x05,OLED_CMD);//

	OLED_WR_Byte(0xD9,OLED_CMD);//Set Pre-Charge Period
	OLED_WR_Byte(0xF1,OLED_CMD);//

	OLED_WR_Byte(0xDA,OLED_CMD);//set com pin configuartion
	OLED_WR_Byte(0x12,OLED_CMD);//

	OLED_WR_Byte(0xDB,OLED_CMD);//set Vcomh
	OLED_WR_Byte(0x30,OLED_CMD);//

	OLED_WR_Byte(0x8D,OLED_CMD);//set charge pump enable
	OLED_WR_Byte(0x14,OLED_CMD);//

	OLED_WR_Byte(0xAF,OLED_CMD);//--turn on oled panel
}



#endif



/**************************/
// 按键处理
#define VK_NULL  '\0'
#define VK_UP    0x26
#define VK_LEFT  0x25
#define VK_DOWN  0x28
#define VK_ESC   0x1b
#define VK_ENTER 0x0d
#define VK_RIGHT 0x27
#define VK_RE_DOWN 0x11
#define VK_RE_LEFT 0x10
#define VK_RE_RIGHT 0x01
/**
 * @brief 获取当前按键，从上到下扫描
 * @return 返回当前的按键值
 */
unsigned char keystate (void) { 
	P2 = 0x7e;
	if (!P2_1) return VK_LEFT ;
	if (!P2_2) return VK_DOWN ;
	if (!P2_3) return VK_RIGHT;
	if (!P2_4) return VK_ESC  ;
	if (!P2_5) return VK_UP   ;
	if (!P2_6) return VK_ENTER;
	return VK_NULL;
}
char isUp = 1;   // 只响应一次
/******************************/

// char addr = OLED_ADDR;
// 用于表示当前场景的枚举变量
enum SCENE { START, MAIN, LIGHT_CONTROL, PWM_CONTROL, INFORMATION_QUERY, EXIT } scene = LIGHT_CONTROL;
unsigned char LED = 0;
int result = 0;
unsigned char oled_clear (char x, char y) __reentrant {
// 	if (y&1) return rand ();    // OLED fill 函数所用 filter 函数 例子
// 	else return 0x00;
	return 0x00;
}
signed char option = 0;                // 选项所用的变量
// signed char light_value [8] = { 0, 5, 15, 25, 30, 35,40, 50 };   // LED 灯的 占空比（百分数）
signed char light_value [8] = { 0 };   // LED 灯的 占空比（百分数）
unsigned int freq = 200;      // 频率（一秒中有多少个周期）
unsigned int timeDuration;    // 当前频率下定时器所需要的数值
unsigned int keyboard_timeDuration;
unsigned int OLED_timeDuration;
signed char duty_max = 20;  // 一周期定时器响应的次数（用于控制亮灭
                              // 否则应当手动计算当前所需的延时时长
							  // 但是因为要同时控制八盏灯的亮暗，只能做满 duty_max 次
unsigned int calcCurrentDuration (unsigned int freq, unsigned int duty_max) {
                              // 用于计算当前的
	return 0xffff-(11059200/freq/duty_max);
}

void draw (void);        // 绘制界面，显示 OLED 内容
void keyboard (void);    // 按键输入，不包括旋转编码器的处理
void KEY_INPUT (void) __interrupt (1);     // 定时按键输入处理（？
void LED_SHOWUP (void) __interrupt (3);    // LED PWM 调光定时器函数
void OLED_SHOWUP (void) __interrupt (5);   // OLED 定时刷新
void main () {

	/**********初始化部分*************/
    // 在单片机上电后或者复位后调用一次
	TMOD = 0x00;         // 0、1 定时器都采用 16 位计时
	EXEN2 = 0x00;
	// PT2 = 0;
	IP = B00001010;
	EA = 1;              // 总中断使能

	timeDuration = calcCurrentDuration (freq, duty_max);  // PWM 一周期对应的计时器数值
	keyboard_timeDuration = 10204;    // 每 5ms 处理一次按键
	OLED_timeDuration = 10204;

	ET0 = 1;        // 定时器0 中断使能
	ET1 = 1;        // 定时器1 中断使能
	ET2 = 1;        // 定时器2 中断使能

	TH0 = (unsigned char)(keyboard_timeDuration >> 8);   // 定时器0 高八位
	TL0 = (unsigned char)(keyboard_timeDuration & 0xff); // 定时器0 低八位
	TH1 = (unsigned char)(timeDuration >> 8);            // 定时器1 高八位
	TL1 = (unsigned char)(timeDuration & 0xff);          // 定时器1 低八位
	TH2 = (unsigned char)(OLED_timeDuration >> 8);       // 定时器2 高八位
	TL2 = (unsigned char)(OLED_timeDuration & 0xff);     // 定时器2 低八位

	OLED_Init ();         // 初始化 OLED 屏幕
	OLED_Fill (oled_clear);

	TR0 = 1;        // 启动 定时器0
	TR1 = 1;        // 启动 定时器1
	TR2 = 1;        // 启动 定时器2


	/**********初始化部分*************/
	while (1) {
		// 主要来写其余的逻辑处理
	}
}


void KEY_INPUT (void) __interrupt (1) {
	unsigned char k = keystate();    // 返回第一个被扫描到的按键（没有采用书上的做法
	static unsigned int flag = 0;            // 0 代表当前是第一次读到这个按键，需要在下一次再进行处理
	flag ++;
	if (flag > 130) isUp = 1;
	if (k == VK_NULL) {              // 如果什么也没有按下，表示当前为弹起状态
		isUp = 1;
		flag = 0;
	} else if (isUp == 1) {          // 如果当前是弹起状态
		if (flag > 1) {
			if (flag > 130) {
				if (flag % 20) goto end;
			}
			isUp = 0;                // 因为有按键被按下，所以标记当前为按下状态
			switch (scene) {
				case START: {
					scene = MAIN;
				} break;
				case MAIN: {
					switch (k) {
						case VK_UP: {
							option ++;
							if (option > 3) option = 0;
						} break;
						case VK_DOWN: {
							option --;
							if (option < 0) option = 3;
						} break;
						case VK_ENTER:
						case VK_RIGHT: {
							switch (option) {
								case 0: scene = LIGHT_CONTROL    ; break;
								case 1: scene = PWM_CONTROL      ; break;
								case 2: scene = INFORMATION_QUERY; break;
								case 3: scene = EXIT             ; break;
							}
						} break;
					}
				} break;
				case LIGHT_CONTROL: {
					switch (k) {
						case VK_UP: {
							option --;
							if (option < 0) option = 7;
						} break;
						case VK_DOWN: {
							option ++;
							if (option > 7) option = 0;
						} break;
						case VK_RIGHT: {
							light_value [option] ++;
							if (light_value[option] > duty_max)
								light_value[option] = duty_max;
						} break;
						case VK_LEFT: {
							light_value [option] --;
							if (light_value[option] < 0)
								light_value[option] = 0;
						} break;
						case VK_ENTER:
						case VK_ESC: {
							scene = MAIN;
							option = 0;
							OLED_Fill (oled_clear);
						} break;
					}
				} break;
			}

		}
	}
end:
	TH0 = (unsigned char)(keyboard_timeDuration >> 8);
	TL0 = (unsigned char)(keyboard_timeDuration & 0xff);
}


void LED_SHOWUP (void) __interrupt (3) {
	static signed char count = 0;

	// TR0 = 0;                        // 暂停计时器
	if (count >= duty_max) count = 0;    // 复位计数器
	// P0 = 0x00;        // 这里无论是0xff 还是 0x00，对效果影响不是很大，但是下面的语句就要从与变成或了
	// FOR (i, 8) {
	// 	P0 &= (count >= light_value[i]) << i;
	// }
	P0_0 = count >= light_value[0];
	P0_1 = count >= light_value[1];
	P0_2 = count >= light_value[2];
	P0_3 = count >= light_value[3];
	P0_4 = count >= light_value[4];
	P0_5 = count >= light_value[5];
	P0_6 = count >= light_value[6];
	P0_7 = count >= light_value[7];
	count ++;
	// if (count >= light) P0 = 0xff;
	// else P0 = 0x00;
	TH1 = (unsigned char)(timeDuration >> 8);
	TL1 = (unsigned char)(timeDuration & 0xff);
	// TH0 = TL0;   // TMOD=0x02 自动完成了从 TL0 到 TH0 的复位
}

void OLED_SHOWUP (void) __interrupt (5) {
	static int i = 0;
	i++;
	if (i > 16) {
		switch (scene) {
			case START: {
				// OLED_ShowString(0,0,"I T",16); 
				OLED_ShowCHinese(16,0,0);//陈
				OLED_ShowCHinese(32,0,1);//笑
				OLED_ShowCHinese(48,0,1);//笑
				OLED_ShowChar (64,0,'&',16);
				OLED_ShowCHinese(64+8,0,5);//
				OLED_ShowCHinese(80+8,0,6);//
				OLED_ShowCHinese(96+8,0,7);//x

				OLED_ShowString(0,3,"0.96' OLED",16);
				OLED_ShowString(0,6,"ASCII:",16);  
				OLED_ShowString(63,6,"CODE:",16);
			} break;
			case MAIN: {
				OLED_ShowString (16, 0,   "LED Control", 16);
				OLED_ShowString (16-4, 2, "SET PWM Freq", 16);
				OLED_ShowString (16, 4,   "Save Status", 16);
				OLED_ShowString (16+28, 6,   "Exit", 16);
			} break;
			case LIGHT_CONTROL: {
				OLED_ShowNum(0,0,option,1,16);
				OLED_ShowNum(0,2,light_value[option],2,16);
				OLED_Set_Pos (20, option);
				int ii;
				FOR (ii, 5*light_value[option])
					OLED_WR_Byte (0xfe, OLED_DATA);
				for (ii = 5*light_value[option]+1; ii < 128-20; ii++) {
					OLED_WR_Byte (0x00, OLED_DATA);
				}
			} break;
		}
	}
	TH2 = (unsigned char)(OLED_timeDuration >> 8);       // 定时器2 高八位
	TL2 = (unsigned char)(OLED_timeDuration & 0xff);     // 定时器2 低八位
}